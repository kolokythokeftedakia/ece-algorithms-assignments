\begin{problem}
	\label{problem_1}
	Ένα δίκτυο υπολογιστών αναπαρίσταται από έναν γράφο $G = (V, E)$ όπου οι κόμβοι αναπαριστούν συσκευές και οι ακμές αναπαριστούν τις συνδέσεις μεταξύ των συσκευών. Κάθε ακμή $(u, v)$ έχει ένα βάρος το οποίο εκφράζει την πιθανότητα $p_{uv}$ ότι ένα πακέτο το οποίο στέλνεται από τη συσκευή $u$ θα φτάσει στην συσκευή $v$ χωρίς να χαθεί. Οι πιθανότητες είναι ανεξάρτητες. Ζητείται το μονοπάτι από την συσκευή $s$ προς τη συσκευή $t$ με τη μέγιστη πιθανότητα επιτυχούς αποστολής.
\end{problem}
\vspace{-6pt}\par
Προτείνουμε τον Αλγόριθμο \ref{alg:2_1}. Δέχεται ως είσοδο έναν γράφο $G=(V,E)$ ο οποίος αναπαρίσταται με adjacency lists τα οποία επιτρέπουν την πρόσβαση στη γειτονιά μιας κορυφής σε γραμμικό χρόνο ως προς το μέγεθος της γειτονιάς \cit{algDesign}, μία κορυφή $s$ η οποία είναι το αρχικό άκρο του ζητούμενου μονοπατιού, μία κορυφή $t$ η οποία είναι το τερματικό άκρο του μονοπατιού και την συνάρτηση βαρών των ακμών $w:E\to[0,1]$. Εφ' όσον τα βάρη των ακμών είναι μη αρνητικά, δύναται να χρησιμοποιηθεί ο αλγόριθμος του Dijkstra ως βάση.\par
%\vspace*{11pt}
Οι διαφορές με τον κλασικό αλγόριθμο του Dijkstra είναι οι ακόλουθες. Αρχικά, αναζήτουμε το μονοπάτι μέγιστου μήκους--πιθανότητας μεταξύ δύο κορυφών $s$ και $t$ αντί του μονοπατιού ελάχιστου μήκους. Επομένως, καθώς εξετάζουμε τις κορυφές του γράφου, η συνθήκη για την ενημέρωση των αποστάσεων των κορυφών από την αφετηρία $s$ είναι $\mathcal{D}[v]<\mathcal{D}[u]\cdot w(u,v),\;\forall(u,v)\in E$.\par
Λόγω της μορφής της παραπάνω ανισότητας, οι αρχικές αποστάσεις όλων των κορυφών έχουν τεθεί ίσες $0$, με εξαίρεση την απόσταση της κορυφής $s$ η οποία αρχικοποιείται σε $\mathcal{D}[s]=1.0$.\par
Τέλος, τα γεγονότα είναι ανεξάρτητα. Δηλαδή, για δύο ακμές $(x,y),(y,z)\in E$ η πιθανότητα επιτυχούς μετάδοσης του σήματος από την κορυφή $x$ στην κορυφή $z$, μέσω των ακμών αυτών είναι $w(x,y)\cdot w(y,z)$. Προκειμένου το γινόμενο $w(x,y)\cdot w(y,z)$ να παίρνει την μέγιστη δυνατή τιμή, πρέπει και τα $w(x,y),w(y,z)$ να είναι τα κατά το δυνατόν μέγιστα.\par
Σε κάθε επανάληψη του βρόχου των γραμμών $13-19$ επιλέγουμε και αφαιρούμε από την ουρά $Q$ την κορυφή με τη μέγιστη απόσταση-πιθανότητα και προχωράμε στη διερεύνηση των κορυφών της γειτονιάς της και την ενημέρωση των αποστάσεών τους (αν χρειάζεται). Έτσι, στο τέλος ο πίνακας $\pi$ περιέχει τον γονέα κάθε κορυφής στο δένδρο μέγιστης πιθανότητας (ο γονέας της ρίζας $s$ είναι $\nil$) και στον πίνακα $\mathcal{D}$ είναι καταχωρημένη η απόσταση-πιθανότητα κάθε κορυφής από τη ρίζα του δένδρου.\par

\input{pseudocode/a2p1.tex}

Για την κατασκευή του μονοπατιού μέγιστης πιθανότητας επιτυχούς αποστολής από την κορυφή $s$ προς την κορυφή $t$ --εάν υπάρχει-- ακολουθούμε τα εξής βήματα. Αρχικά, σε έναν κενό πίνακα $\mathcal{P}$ προσθέτουμε την κορυφή $t$. Σκοπός μας είναι να διασχίσουμε το δένδρο από την κορυφή $t$ προς την κορυφή $s$ προσθέτοντας την κορυφή που συναντάμε σε κάθε βήμα, στο μονοπάτι $\mathcal{P}$.\par
Μετά την εκτέλεση της γραμμής $22$ ο πίνακας $\mathcal{P}$ περιέχει μία μόνο κορυφή, την $t$. Ελέγχουμε εάν ο γονέας της είναι ίσος με $\nil$. Εάν όχι, προσθέτουμε τον γονέα στην πρώτη θέση του $\mathcal{P}$ και επαναλαμβάνουμε τον προηγούμενο έλεγχο για τον γονέα της κορυφής του μονοπατιού που προστέθηκε τελευταία. Η διαδικασία επαναλαμβάνεται έως ότου ο γονέας της τελευταίας κορυφής που προστέθηκε στο μονοπάτι $\mathcal{P}$ να είναι $\nil$. Τότε, η κορυφή αυτή είναι αναγκαστικά η $s$ και το μονοπάτι έχει τη μορφή $\mathcal{P}=\left\langle s,v_0,\ldots,v_k,t\right\rangle$.\par
\vspace*{6pt}\par
Σε ό,τι αφορά τον χρόνο εκτέλεσης του Αλγορίθμου \ref{alg:2_1} ισχύουν τα παρακάτω.\par
Στην γραμμή $2$ δημιουργείται ένα κενό maximum priority queue $Q$ σε χρόνο $\bigO(1)$. Στις γραμμές $2$, $3$ και $4$ δημιουργούνται τρεις νέοι κενοί πίνακες, ο καθένας σε σταθερό χρόνο.\par
Σε κάθε μία από τις γραμμές $6$ και $7$ πραγματοποιείται μία καταχώρηση σε συγκεκριμένη θέση των πινάκων $\pi$ και $\mathcal{D}$ αντίστοιχα, σε σταθερό χρόνο. Συνεπώς, το σύνολο των γραμμών $2-7$ εκτελείται σε χρόνο $\bigO(1)$.\par
Το σώμα της \textbf{for} των γραμμών $8-10$ εκτελείται $|V|$ φορές. Κάθε μία από τις γραμμές $9$ και $10$ εκτελεί σε σταθερό χρόνο μία καταχώρηση σε συγκεκριμένη θέση των πινάκων $\pi$ και $\mathcal{D}$ αντίστοιχα. Άρα, ο συνολικός χρόνος εκτέλεσης των γραμμών $8-10$ είναι $\bigO(|V|-1)=\bigO(|V|)$.\par
Η γραμμή $12$ τρέχει σε χρόνο $T_{Q,\tw{insert}}$, $|V|$ φορές. Ο χρόνος $T_{Q,\tw{insert}}$ εξαρτάται από την υλοποίηση του priority queue. Τότε, ο συνολικός χρόνος εκτέλεσης των γραμμών $11-12$ είναι $|V|\cdot T_{Q,\tw{insert}}$.\par

Το σώμα του \textbf{while} των γραμμών $13-19$ εκτελείται $|V|$ φορές. Η μέθοδος $\tw{extract\_max}(\cdot,\cdot)$ για το $Q$ εκτελείται σε χρόνο $T_{Q,\tw{extract\_max}}$ και η καταχώρηση του αποτελέσματος γίνεται σε σταθερό χρόνο. Δηλαδή, η γραμμή $14$ εκτελείται σε $T_{Q,\tw{extract\_max}}+\bigO(1) = T_{Q,\tw{extract\_max}}$ χρόνο. Το σώμα της \textbf{for} των γραμμών $15-19$ εκτελείται το πολύ $|E|$ φορές. Σε κάθε εκτέλεση, ο έλεγχος της συνθήκης της γραμμής $16$ πραγματοποιείται σε σταθερό χρόνο. Ο πολλαπλασιασμός και η καταχώρηση του αποτελέσματος στη γραμμή $17$ εκτελούνται σε σταθερό χρόνο. Ομοίως και η καταχώρηση της γραμμής $19$. Η μέθοδος $\tw{update\_priority}(\cdot,\cdot,\cdot)$ απαιτεί χρόνο $T_{Q,\tw{update\_priority}}$ και εξαρτάται από την υλοποίηση της $Q$.\par

Ο έλεγχος της γραμμής $20$ εκτελείται μία φορά σε σταθερό χρόνο και αν είναι αληθής, o program counter προχωράει στην γραμμή $21$ η οποία εκτελείται σε χρόνο $\bigO(1)$ και τερματίζει την διαδικασία.\par

Οι καταχωρήσεις των γραμμών $22$ και $23$ απαιτούν σταθερό χρόνο.\par

Το σώμα του \textbf{while} των γραμμών $24-26$ μπορεί να εκτελεστεί έως και $|V|$ φορές. Κάθε μία από τις γραμμές $25$ και $26$ τρέχει σε σταθερό χρόνο $\bigO(1)$. Άρα, ο συνολικός χρόνος εκτέλεσης των γραμμών $24-26$ είναι $\bigO(|V|)$. \par

Η γραμμή $27$ τρέχει σε σταθερό χρόνο. Τελικά, ο συνολικός χρόνος εκτέλεσης του Αλγορίθμου \ref{alg:2_1} είναι $T(|V|,|E|)=\bigO(1)+\bigO(|V|)+|V|\cdot T_{Q,\tw{insert}}+|V|\cdot T_{Q,\tw{extract\_min}}+|E|\cdot T_{Q,\tw{update\_priority}}+\bigO(|V|)$. Δηλαδή,

\begin{equation}
\label{eq:running_time_1}
\begin{split}
    T(|V|,|E|)=&|V|\cdot T_{Q,\tw{insert}}\\+&|V|\cdot T_{Q,\tw{extract\_min}}\\+&|E|\cdot T_{Q,\tw{update\_priority}}.
\end{split}
\end{equation}

Η σχέση \eqref{eq:running_time_1} είναι σύμφωνη με τον χρόνο εκτέλεσης του αλγορίθμου του Dijkstra\cit{handbook}\cit{algDesign} και εξαρτάται από την υλοποίηση του priority queue.
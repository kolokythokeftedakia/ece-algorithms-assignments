\begin{problem}
	\label{problem1}
	Εν όψει εκλογών, έχουμε δημοσκοπικά δεδομένα για κάθε χωριό και πόλη της περιφέρειας που μας ενδιαφέρει. Για κάθε μία από αυτές τις τοποθεσίες γνωρίζουμε τι δήλωσε ο κάθε πολίτης, που πήρε μέρος στη δημοσκόπηση, πως προτίθεται να ψηφίσει. Θέλουμε να μάθουμε εάν υπάρχει υποψήφιος (και ποιος είναι αυτός) ο οποίος έχει συγκεντρώσει περισσότερες από τις μισές ψήφους σε ένα συγκεκριμένο μέρος.
\end{problem}

Το \textbf{Προβλήμα \ref{problem1}} αναφέρεται στο μέγεθος των \textsl{μισών ψήφων}, το οποίο μπορεί να ερμηνευθεί είτε ως προς το πλήθος των πολιτών οι οποίοι συμμετείχαν στη δημοσκόπηση, είτε ως προς τον συνολικό πληθυσμό της τοποθεσίας, ανεξαρτήτως του αριθμού των συμμετεχόντων στη δημοσκόπηση. Για την πρώτη ερμηνεία, ως είσοδο χρειαζόμαστε μόνον τον πίνακα των υποψηφίων και τα αποτελέσματα της δημοσκόπησης, ενώ για την δεύτερη ερμηνεία χρειαζόμαστε ως είσοδο μία επιπλέον σταθερά η οποία θα μας πληροφορεί για τον συνολικό πληθυσμό της τοποθεσίας. Στις επόμενες ενότητες υιοθετούμε την πρώτη ερμηνεία. Ωστόσο, ας σημειωθεί πως η προσαρμογή των προτεινόμενων αλγορίθμων στην δεύτερη περίπτωση είναι εύκολη και δεν επηρεάζει τον χρόνο εκτέλεσής τους.

\section{Επίλυση σε $\bigO(n^2)$}

	Στην ενότητα αυτή προτείνεται ένας αλγόριθμος επίλυσης του \textbf{Προβλήματος \ref{problem1}} ο οποίος θα αποδείξουμε πως έχει χρόνο εκτέλεσης $\bigO(n^2)$.\par
	\begin{wrapfigure}{R}{0.56\textwidth}
		\begin{minipage}{0.56\textwidth}
			\vspace*{-20pt}
			\input{pseudocode/1_1.tex}
		\end{minipage}
	\end{wrapfigure}
	Στην πραγματικότητα καλούμαστε να υπολογίσουμε τη συχνότητα εμφάνισης κάθε στοιχείου ενός μονοδιάστατου πίνακα, στον πίνακα αυτόν. Στη συνέχεια, πρέπει να βρούμε -- εάν υπάρχουν --  τα στοιχεία των οποίων η συχνότητα εμφάνισης πληροί ένα συγκεκριμένο κριτήριο. Στην περίπτωση του \textbf{Προβλήματος \ref{problem1}} ο πίνακας αυτός είναι τα αποτελέσματα της δημοσκόπησης και η συχνότητα εμφάνισης κάθε υποψηφίου ισοδυναμεί με τις ψήφους που έχει καταφέρει να συγκεντρώσει στη συγκεκριμένη τοποθεσία. Τέλος, πρέπει να βρούμε εάν υπάρχει και ποιος είναι αυτός ο υποψήφιος ο οποίος έχει συγκεντρώσει περισσότερες από τις μισές ψήφους.\par
	Για την παραπάνω διαδικασία προτείνουμε τον ακόλουθο αλγόριθμο. Για κάθε έναν υποψήφιο εκτελούμε τα παρακάτω βήματα. Πρώτον αρχικοποιούμε το πλήθος των ψήφων του εκάστοτε υποψηφίου σε $0$ (μηδέν). Έπειτα, για τον εκάστοτε υποψήφιο, διαβάζουμε τον πίνακα των αποτελεσμάτων της δημοσκόπησης και κάθε φορά που συναντάμε το όνομά του προσαυξάνουμε το πλήθος των ψήφων του κατά $1$. Στη συνέχεια, ελέγχουμε εάν έχει συγκεντρώσει περισσότερες από τις μισές ψήφους. Εάν ναι, προσθέτουμε το ονοματεπώνυμό του σε έναν -- έως τώρα κενό -- μονοδιάστατο πίνακα τον οποίο και επιστρέφουμε και τερματίζουμε τη διαδικασία. Ειδάλλως, συνεχίζουμε στον επόμενο υποψήφιο. Στην περίπτωση κατά την οποία δεν πληροί κανένας υποψήφιος το παραπάνω κριτήριο επιστρέφουμε έναν κενό πίνακα. Όλα τα παραπάνω δίνονται σε μορφή ψευδογλώσσας στο \textbf{Algorithm \ref{alg:1_1}}.\par
	Θα αναλύσουμε τον χρόνο εκτέλεσης του παραπάνω αλγορίθμου με τη βοήθεια της υλοποίησης σε ψευδογλώσσα. Έστω πως υπάρχουν $M$ υποψήφιοι και $N$ πολίτες συμμετείχαν στη δημοσκόπηση. Η γραμμή $2$ έχει σταθερό χρόνο εκτέλεσης $\bigO(1)$. Το σώμα της \texttt{\textbf{for}} (γραμμές $4$--$12$) εκτελείται το πολύ $M$ φορές. Η γραμμή $4$ τρέχει σε σταθερό χρόνο $\bigO(1)$. Ο έλεγχος της συνθήκης της γραμμής $6$ πραγματοποιείται $M\cdot N$, το πολύ, φορές και εκτελείται πάντα σε σταθερό χρόνο $\bigO(1)$. Ομοίως, η γραμμή $7$ είναι και αυτή σταθερής χρονικής πολυπλοκότητας και εκτελείται το πολύ $M\cdot N$ φορές. Παρόμοια, η συνθήκη της γραμμής $10$ εκτελείται $M$, το πολύ, φορές σε σταθερό χρόνο $\bigO(1)$ και οι γραμμές $11$ και $12$  εκτελούνται το πολύ μία φορά. Τέλος, η γραμμή $15$ εκτελείται μια, το πολύ, φορά σε σταθερό χρόνο $\bigO(1)$. Επομένως, για τον χρόνο εκτέλεσης του \textbf{Algorithm \ref{alg:1_1}}, $T_1$, έχουμε
	\begin{equation*}
		T_1(N,M)=\bigO(1)+M\cdot\left\{\bigO(1)+N\cdot\left[\bigO(1)+\bigO(1)\right]+\bigO(1)+\bigO(1)+\bigO(1)\right\}+\bigO(1)
	\end{equation*}
	δηλαδή
	\begin{equation}
		\label{eq:1_1_T(N,M)}
		T_1(N,M)=\bigO(M\cdot N).
	\end{equation}

	Χωρίς βλάβη της γενικότητας θέτουμε $n=\max\left\{M,N\right\}$. Τότε, η έκφραση \eqref{eq:1_1_T(N,M)} του χρόνου εκτέλεσης του {Algorithm \ref{alg:1_1}} γίνεται
	\begin{equation}
		\label{eq:1_1_T(n)}
		T_1(n)=\bigO(n^2)
	\end{equation}

	\qed

\section{Επίλυση σε $\bigO(n_{\;}\mathrm{lg_{\;}}n)$ χρήσει \dnc}

	Στην παρούσα ενότητα επιλύουμε το \textbf{Πρόβλημα \ref{problem1}} προτείνοντας έναν αλγόριθμο  χρονικής πολυπλοκότητας $\bigO\(n\lg n\)$ ο οποίος έχει σχεδιαστεί ακολουθώντας την πρακτική \dnc. Παρακάτω, αναλύουμε τον αλγόριθμο αυτόν, προτείνουμε μία υλοποίησή του σε ψευδογλώσσα και αποδεικνύουμε πως όντως είναι χρονικής πολυπλοκότητας $\bigO\(n\lg n\)$.\par
	\vspace*{20pt}
	Ο αλγόριθμος που προτείνουμε ακολουθεί το σύνηθες μοτίβο των αλγορίθμων της λογικής \dnc. Ως είσοδο δέχεται έναν πίνακα με τα ονόματα όλων των υποψηφίων $\mathtt{C}$ (με πληθάριθμο $M$) και έναν δεύτερο πίνακα $\mathtt{P}$ (με πληθάριθμο $N$), κάθε στοιχείο του οποίου αντιπροσωπεύει την ψήφο ενός πολιτη (η ψήφος καταγράφεται με το ονοματεπώνυμο του υποψηφίου). Ως έξοδο, επιστρέφουμε έναν πίνακα ενός στοιχείου ο οποίος περιέχει το όνομα -- αν υπάρχει -- του υποψηφίου που έχει συγκεντρώσει περισσότερες από τις μισές ψήφους. Ειδάλλως, επιστρέφεται ένας κενός πίνακας.\par
	Αρχικά, δημιουργούμε μία mutable δομή $\mathtt{D}$ στην οποία αποθηκεύουμε δυάδες κλειδιών \textsl{\en{(keys)}} με τις αντίστοιχες τιμές τους \textsl{\en{(values)}}, παρόμοια με ένα \en{hashtable} ή με ένα \en{dictionary} της γλώσσας \en{Python} \cit{pythondict}. Μία τέτοια δομή επιτρέπει την αναζήτηση ενός κλειδιού (και την πρόσβαση στην τιμή που συνοδεύει το κλειδί) σε σταθερό χρόνο $\bigO(1)$ \footnote{\textsl{From a practical standpoint, the most important hash technique invented in the late 1970s is probably the method that Witold Lipski called \textbf{linear hashing}. [\ldots]\newline
	\indent In the theoretical realm, more complicated methods have been devised by which it is possible to guarantee $\bigO(1)$ maximum time per access, with $\bigO(1)$ average amortized time per insertion and deletion, regardless of the keys being examined; moreover, the total storage used at any time is bounded by a constant times the number of items currently present, plus another additive constant.} \cit{knuthArt3}} \footnote{Η χρήση μίας τέτοιας δομής αν και εξυπηρετεί την μείωση του χρόνου εκτέλεσης, επιβαρύνει την χωρική πολυπλοκότητα του αλγορίθμου. Δηλαδή, απαιτείται δέσμευση περισσότερης μνήμης.}. Σκοπός μας είναι να έχουμε πρόσβαση στο πλήθος των ψήφων ενός υποψηφίου σε σταθερό χρόνο $\bigO(1)$. Συνεπώς, τα κλειδιά στην δομή αυτή θα είναι τα ονόματα των υποψηφίων και η τιμή θα αντιπροσωπεύει το πλήθος των ψήφων που έχει συγκεντρώσει ο εκάστοτε υποψήφιος. Επομένως, για όλα τα κλειδιά, η αρχική τιμή θα είναι μηδέν.\par
	Εν συνεχεία, δημιουργούμε έναν κενό πίνακα $\mathtt{POP\_CAND}$ στον οποίο, εάν κάποιος υποψήφιος έχει συγκεντρώσει περισσότερες από τις μισές ψήφους θα προσθέσουμε το όνομά του. Στο τέλος της διαδικασίας θα επιστρέψουμε τον πίνακα αυτόν είτε είναι κενός, είτε περιέχει ένα (μόνο) ονοματεπώνυμο.\par
	Έπειτα, ξεκινάμε την διαδικασία προσμέτρησης των ψήφων. Ελέγχουμε εάν το μήκος του πίνακα των ψήφων είναι γνησίως μεγαλύτερο του μηδενός. Εάν ο έλεγχος ήταν αληθής, πραγματοποιούμε έναν δεύτερο έλεγχο· εάν το μήκος του πίνακα, δηλαδή το πλήθος των στοιχείων του, είναι ακριβώς ίσο με το $1$ ή εάν είναι μεγαλύτερο του $1$. Τότε, έχουμε τις εξής περιπτώσεις:\begin{enumerate}[label=\roman*.]
			\item \textbf{το πλήθος των στοιχείων είναι} $N>1$. Υποθέτουμε πως το τρέχον στιγμιότυπο της διαδικασίας προσμέτρησης των ψήφων είναι το $\mathtt{F}$. Τότε, δημιουργούμε έναν νέο πίνακα $\mathtt{P_{left}}$ ο οποίος αποτελεί διαμέριση του αρχικού πίνακα από το index $0$ έως και $\left\lceil\sfrac{N}{2}\right\rceil-1$, δηλαδή θα είναι $\mathtt{P_{left}=P}\left[0:\left\lceil\sfrac{N}{2}\right\rceil\right]$ και επαναλαμβάνουμε αναδρομικά τη διαδικασία προσμέτρησης ψήφων έχοντας ως είσοδο τον νέο υποπίνακα $\mathtt{P_{left}}$. Μόλις επιστρέψουμε στο στιγμιότυπο $\mathtt{F}$ της διαδικασίας, δημιουργούμε και πάλι έναν νέο πίνακα $\mathtt{P_{right}}$ ο οποίος αποτελεί διαμέριση του αρχικού πίνακα από το index $\left\lceil\sfrac{N}{2}\right\rceil$ έως και $N-1$, δηλαδή θα είναι $\mathtt{P_{right}=P}\left[\left\lceil\sfrac{N}{2}\right\rceil:N\right]$ και επαναλαμβάνουμε αναδρομικά τη διαδικασία προσμέτρησης ψήφων έχοντας ως είσοδο τον νέο υποπίνακα $\mathtt{P_{right}}$. Επιστρέφοντας στο στιγμιότυπο $\mathtt{F}$ της διαδικασίας δεν μένει παρά να επιστρέψουμε στην όποια διαδικασία δημιούργησε το στιγμιότυπο $\mathtt{F}$.
			\item \textbf{το πλήθος των στοιχείων είναι} $N=1$. Υποθέτουμε πως το τρέχον στιγμιότυπο της διαδικασίας προσμέτρησης των ψήφων είναι το $\mathtt{F}$. Τότε, αυξάνουμε την τιμή \textsl{(value)} που αντιστοιχεί στο κλειδί \textsl{(key)} $\mathtt{P[0]}$ της δομής $\mathtt{D}$, κατά $1$. Έπειτα, επιστρέφουμε στη διαδικασία η οποία δημιούργησε το $\mathtt{F}$.
		\end{enumerate}

	Μόλις τελειώσει η διαδικασία προσμέτρησης ψήφων, στη δομή $\mathtt{D}$ θα είναι αποθηκευμένο το πλήθος των ψήφων που συγκέντρωσε κάθε υποψήφιος. Στη συνέχεια, για κάθε έναν υποψήφιο ελέγχουμε -- μέσω της δομής $\mathtt{D}$ -- εάν οι ψήφοι που έχει συγκεντρώσει είναι περισσότερες από τις μισές. Εάν ναι, προσθέτουμε το ονοματεπώνυμό του στον πίνακα $\mathtt{POP\_CAND}$, επιστρέφουμε τον πίνακα και τερματίζουμε τη διαδικασία. Διαφορετικά, συνεχίζουμε στον επόμενο υποψήφιο. Εάν κανείς δεν έχει συγκεντρώσει παραπάνω από τις μισές ψήφους, επιστρέφουμε τον κενό πίνακα $\mathtt{POP\_CAND}$ και τερματίζουμε τη διαδικασία.\par
	\vspace*{10pt}
	Συνοψίζοντας, διαιρέσαμε αναδρομικά το αρχικό πρόβλημα μεγέθους $N$ σε δύο υποπροβλήματα ίσου μεγέθους $(\pm 1)$ έως ότου να εκφυλιστεί σε $N$ προβλήματα μεγέθους $1$. Όλα τα παραπάνω, σε μορφή ψευδοκώδικα, δίνονται στο \textbf{Algorithm \ref{alg:1_2}}, όπου ξεκινάμε από την διαδικασία \texttt{MAIN} στη γραμμή \mono{18} και η διαδικασία \texttt{FREQUENCY} αντιστοιχεί στην διαδικασία προσμέτρησης των ψήφων.

	\input{pseudocode/1_2.tex}

	Σε ό,τι αφορά τη χρονική πολυπλοκότητα του \textbf{Algorithm \ref{alg:1_2}} θα έχουμε: η χρονική πολυπλοκότητα κάθε μίας από τις γραμμές ${19}$, ${23}$ και ${25}$ είναι σταθερού χρόνου, δηλαδή $\bigO(1)$. Η γραμμή ${20}$ και το σώμα της \texttt{\textbf{for}} εκτελούνται $M$ φορές -- κάθε φορά για ένα διαφορετικό στοιχείο του $\mathtt{C}$ -- και η γραμμή ${20}$ εκτελείται μία επιπλέον φορά, όπου πλέον δεν υπάρχουν στοιχεία του $\mathtt{C} $ τα οποία δεν έχουν ελεγχθεί και έτσι ο program counter προχωρά στην γραμμή ${23}$. Επομένως, η χρονική πολυπλοκότητα των γραμμών ${20}$--${22}$ είναι $\bigO(M+1)$, δηλαδή $\bigO(M)$. Για την γραμμή ${24}$ υποθέτουμε χρόνο εκτέλεσης $T_{F}(N,M)$. Για την \texttt{\textbf{for}} της γραμμής ${26}$ και το σώμα της, με την ίδια ανάλυση που έγινε για την \texttt{\textbf{for}} της γραμμής ${20}$, καταλήγουμε σε $T(M)=M\cdot\left[\bigO(1)+\bigO(1)+\bigO(1)\right]=\bigO(M)$. Για την γραμμή ${32}$ είναι $\bigO(1)$. Συνεπώς, ο χρόνος εκτέλεσης του \textbf{Algorithm \ref{alg:1_2}}, $T_2$, υπολογίζεται ως $T_{2}(N,M)=\bigO(1)+\bigO(M)+\bigO(1)+T_{F}(N,M)+\bigO(1)+\bigO(M)+\bigO(1)$. Δηλαδή, θα είναι
	\begin{equation}
		\label{eq:T_2}
		T_{2}(N,M)=T_{F}(N,M)+\bigO(M)
	\end{equation}

	Επόμενο βήμα είναι ο υπολογισμός του χρόνου εκτέλεσης της διαδικασίας \texttt{FREQUENCY} (γραμμές $1$--$17$), $T_{F}(N,M)$. Το βασικό ζήτημα είναι ο προσδιορισμός της χρονικής πολυπλοκότητας των αναδρομών. Δύο τρόποι προσέγγισης, δεδομένου πως ο αλγόριθμος ακολουθεί τη σχεδιαστική αρχή \dnc, είναι το \textbf{Master Theorem} και το \textbf{δένδρο αναδρομών} (recursion tree). Αρχικά παραθέτουμε το Master Theorem \cit{dasgupta}\cit{handbook}.

	\vspace*{20pt}
	\textsl{Έστω ένα πρόβλημα μεγέθους $n$ το οποίο προσεγγίζεται επιλύοντας αναδρομικά $a$ υποπροβλήματα μεγέθους $\sfrac{n}{b}$ και συνδυάζοντας τις επιμέρους λύσεις σε $\bigO(n^d)$ χρόνο, για κάποια $a,b,d>0$. Ο χρόνος εκτέλεσης είναι}
	\begin{equation}
		\label{eq:T(n)_DnC}
		T(n)=aT\(\left\lceil\frac{n}{b}\right\rceil\)+\bigO(n^d).
	\end{equation}

	\begin{theorem}[Master Theorem]
		\label{theorem:master_theorem}
		Εάν είναι $\displaystyle{T(n)=aT\(\left\lceil\frac{n}{b}\right\rceil\)+\bigO(n^d)}$ για κάποιες σταθερές $a>0$, $b>1$ και $d\geqslant 0$, τότε
		\begin{equation}
			T(n)=\begin{cases}
				\bigO(n^d)\quad\quad\quad\text{if}\;d>\log_{b}{a}\\
				\bigO(n^d\lg{n})\quad\text{ if}\;d=\log_{b}{a}\\
				\bigO(n^{\log_{b}{a}})\quad\;\text{ if}\;d<\log_{b}{a}.
			\end{cases}
		\end{equation}
	\end{theorem}
	\vspace*{20pt}

	Στο \textbf{Algorithm \ref{alg:1_2}}, το πρόβλημα μεγέθους $N$ το διαμελίζουμε σε δύο υποπροβλήματα μεγέθους $\sfrac{N}{2}$. Δηλαδή, με όρους του Master Theorem, $a=2$ και $b=2$. Οι γραμμές ${2}$, ${3}$, ${4}$, ${5}$, ${6}$, ${8}$ αφορούν την διάσπαση του προβλήματος στα επιμέρους υποπροβλήματα και κάθε εκτέλεσή τους γίνεται σε σταθερό χρόνο $\bigO(1)$. Οι γραμμές ${10}$ και ${11}$ αφορούν τη διαδικασία που λαμβάνει χώρα στο βαθύτερο επίπεδο της αναδρομής και κάθε εκτέλεσή τους πραγματοποιείται σε επίσης σταθερό χρόνο $\bigO(1)$. Ο συνδυασμός των λύσεων των υποπροβλημάτων είναι στην πραγματικότητα η εντολή \textbf{\texttt{return}} της γραμμής $16$ κάθε εκτέλεση της οποίας κοστίζει $\bigO(1)$ χρόνο καθώς η μόνη της δουλειά είναι να επιστρέψει στην διαδικασία από την οποία κλήθηκε το τρέχον στιγμιότυπο της \texttt{FREQUENCY}.  Δηλαδή, ο συνδυασμός όλων των λύσεων πραγματοποιείται σε χρόνο $N\cdot\bigO(1)=\bigO(N)$. Συνεπώς, είναι $d=1=\log_2{2}$, δηλαδή ο χρόνος εκτέλεσης της διαδικασίας \texttt{FREQUENCY} \footnote{Στην εξίσωση \eqref{eq:T_2} κάναμε την γενική υπόθεση πως ο χρόνος $T_{F}$ είναι συνάρτηση των $N$ και $M$. Τελικά, μετά την μελέτη της υπορουτίνας \texttt{FREQUENCY}, καταλήγουμε πως ο χρόνος εκτέλεσης $T_{F}$ είναι συνάρτηση μόνον του $N$.} είναι

	\begin{equation}
		\label{eq:T_F(N)}
		T_{F}(N)=\bigO(N\lg{N}).
	\end{equation}

	Συνδυάζοντας τις εξισώσεις \eqref{eq:T_2} και \eqref{eq:T_F(N)} προκύπτει

	\begin{equation*}
		T_{2}(N,M)=\bigO(N\lg{N})+\bigO(M).
	\end{equation*}

	Χωρίς βλάβη της γενικότητας θέτουμε $n=\max\left\{N,M\right\}$. Τότε, η προηγούμενη έκφραση του χρόνου εκτέλεσης του \textbf{Algorithm \ref{alg:1_2}} γίνεται $T_{2}(n)=\bigO(n\lg{n})+\bigO(n)$, δηλαδή

	\begin{equation}
		\label{eq:alg_1.2a_O(nlgn)}
		T_{2}(n)=\bigO(n\lg{n}).
	\end{equation}

	\qed

	\vspace*{20pt}
	Θα αποδείξουμε την χρονική πολυπλοκότητα της υπορουτίνας \texttt{FREQUENCY}, $T_{F}(N)$, και χρήσει του δένδρου αναδρομών. Αρχικά παραθέτουμε κάποιους χρήσιμους ορισμούς και θεωρήματα σχετικά με τα \textsl{δένδρα με ρίζα}.

	\begin{definition}[Επίπεδο ή βάθος]
		Το \textbf{επίπεδο} ή \textbf{βάθος} μιας κορυφής $v$ είναι η απόστασή της από την ρίζα. Η ρίζα του δένδρου έχει βάθος $0$. \cit{gross2019graph}
	\end{definition}
	\begin{definition}[Ύψος]
		Το \textbf{ύψος} ενός δένδρου με ρίζα είναι το μήκος του μεγαλύτερου μονοπατιού από την ρίζα προς κάθε άλλη κορυφή ή διαφορετικά το μέγιστο των επιπέδων του δένδρου. \cit{rosen}
	\end{definition}
	\begin{definition}[$m$-αδικό δένδρο]
		Ένα δένδρο με ρίζα καλείται \textbf{$m$-αδικό δένδρο}, εάν κάθε εσωτερική κορυφή δεν έχει περισσότερα από $m$ παιδιά. \cit{rosen}
	\end{definition}
	\begin{definition}[Γεμάτο $m$-αδικό δένδρο]
		Ένα δένδρο με ρίζα καλείται \textbf{γεμάτο $m$-αδικό δένδρο}, εάν κάθε εσωτερική κορυφή  έχει ακριβώς $m$ παιδιά \cit{rosen}
	\end{definition}
	\begin{definition}[Ισοζυγισμένο δένδρο]
		Ένα δυαδικό δένδρο είναι \textbf{ισοζυγισμένο}, εάν για κάθε ακμή, το πλήθος των κορυφών του δεξιού και του αριστερού υποδένδρου του διαφέρουν το πολύ κατά ένα. \cit{gross2019graph}
	\end{definition}
	\begin{theorem}
		\label{thrm:tree_h}
		Για ένα $m$-αδικό δένδρο με ύψος $h$ και $l$ φύλλα ισχύει $h\geqslant\left\lceil\log_m{l}\right\rceil$. Εάν το δένδρο είναι γεμάτο $m$-αδικό και ισοζυγισμένο, τότε είναι  $h=\left\lceil\log_m{l}\right\rceil$. \cit{rosen}
	\end{theorem}

	\begin{wrapfigure}{R}{0.5\textwidth}
		\begin{minipage}{0.5\textwidth}
			\input{tree.tex}
		\end{minipage}
		\caption{Δένδρο αναδρομών της διαδικασίας \texttt{FREQUENCY}.}
		\label{tree:1_2}
		\vspace*{-9pt}
	\end{wrapfigure}
	Όπως αναφέρθηκε παραπάνω, κάθε μία από τις γραμμές ${2}$, ${3}$, ${4}$, ${5}$, ${6}$, ${8}$, ${10}$, $11$ και ${16}$ εκτελείται σε $\bigO(1)$ χρόνο. Επομένως, η διαίρεση του προβλήματος στα επιμέρους προβλήματα και ο συνδυασμός των επιμέρους λύσεων γίνονται σε σταθερό χρόνο. Σε σταθερό χρόνο εκτελείται και η καταμέτρηση της ψήφου (όταν, δηλαδή, το μέγεθος του υποπροβλήματος είναι $1$). Υποθέτουμε πως ο σταθερός χρόνος που απαιτείται για τις παραπάνω διαδικασίες είναι $\tau $. Τότε, προκύπτει ένα δένδρο αναδρομών όπως του \textbf{Σχήματος \ref{tree:1_2}}.\par
	Στην γενική περίπτωση, το εν λόγω δένδρο αναδρομών δεν θα είναι πάντα ισοζυγισμένο αλλά θα είναι πάντα γεμάτο (λόγω του τρόπου κατασκευής του). Ωστόσο, εφ' όσον μελετάμε τη χρονική πολυπλοκότητα στην χειρότερη περίπτωση, θεωρούμε πως για δεδομένο μέγεθος αρχικού προβλήματος, θα είναι ισοζυγισμένο. Έτσι, λοιπόν, το δένδρο έχει $\displaystyle{\left\lceil\lg{N}\right\rceil+1}$ επίπεδα (θεώρημα \ref{thrm:tree_h}) και $N$ φύλλα. Κάθε επίπεδο $L$ συνεισφέρει στον συνολικό χρόνο εκτέλεσης κατά $2^{L}\cdot\left[\tau \cdot\(\sfrac{N}{2^{L}}\)\right]=\tau \cdot N$. Άρα, ο συνολικός χρόνος εκτέλεσης της διαδικασίας \texttt{FREQUENCY} είναι
	\begin{align*}
		T_F(N)&=\bigO\(\tau \cdot N\cdot\(\left\lceil\lg{N}\right\rceil+1\)\)\\
		&=\bigO\(\tau \cdot N\cdot\left\lceil\lg{N}\right\rceil+\tau \cdot N\)
	\end{align*}
	δηλαδή
	\begin{equation}
		\label{eq:T_F(N,M)_tree}
		T_F(N)=\bigO\(N\lg{N}\).
	\end{equation}

	Συνδυάζοντας τις εξισώσεις \eqref{eq:T_2} και \eqref{eq:T_F(N,M)_tree} έχουμε

	\begin{equation}
		\label{eq:T_2(N,M)_tree}
		T_2(N,Μ)=\bigO\(N\lg{N}\)+\bigO\(M\).
	\end{equation}

	Τέλος, χωρίς βλάβη της γενικότητας, θέτουμε και πάλι $n=\max\left\{N,M\right\}$ και η \eqref{eq:T_2(N,M)_tree} γράφεται
	\begin{equation}
		T_2(n)=\bigO\(n\lg{n}\)
	\end{equation}
	\qed

\section{Επίλυση σε $\bigO(n)$}

Για την επίλυση του \textbf{Προβλήματος \ref{problem1}} σε χρόνο $\bigO(n)$ θα στηριχτούμε στον αλγόριθμο της προηγούμενης ενότητας. Συγκεκριμένα, θα χρησιμοποιήσουμε και πάλι μια δομή dictionary μέσω της οποίας θα επιτυγχάνουμε πρόσβαση στις ψήφους κάθε υποψηφίου σε, κατά μέσο όρο, χρόνο $\bigO(1)$ \cit{knuthArt3}. Ο αλγόριθμος της παρούσης ενότητας διαφοροποιείται από αυτόν της προηγούμενης στην μέθοδο της καταμέτρησης των ψήφων. Προηγουμένως, η καταμέτρηση έγινε αναδρομικά, ενώ τώρα θα πραγματοποιηθεί με σειριακή προσπέλαση του πίνακα των αποτελεσμάτων της δημοσκόπησης. Έχοντας, λοιπόν, αυτό το σκαρίφημα προχωράμε στην αναλυτική περιγραφή του αλγορίθμου.\par
\vspace*{18pt}
\begin{wrapfigure}{R}{0.6\textwidth}
	\begin{minipage}{0.6\textwidth}
	\vspace*{-12pt}
		\input{pseudocode/1_3.tex}
	\end{minipage}
\end{wrapfigure}
	Ως είσοδο έχουμε έναν πίνακα $\mathtt{C}$, $M$ στοιχείων, στον οποίο είναι αποθηκευμένα τα ονοματεπώνυμα όλων των υποψηφίων και έναν πίνακα $\mathtt{P}$, $N$ στοιχείων, ο οποίος περιέχει τις ψήφους των πολιτών που συμμετείχαν στη δημοσκόπηση. Ως έξοδος επιστρέφεται είτε ένας κενός πίνακας, είτε ένας πίνακας με το ονοματεπώνυμο του υποψηφίου ο οποίος έχει συγκεντρώσει περισσότερες από τις μισές ψήφους.\par
	Πρώτο βήμα είναι η δημιουργία μίας κενής mutable δομής dictionary, $\mathtt{D}$, στην οποία θα αποθηκεύονται συμβολοσειρές ως κλειδιά \textsl{(keys)} και μη αρνητικοί ακέραιοι ως τιμές \textsl{(values)}. Τον ρόλο των κλειδιών, στην προκειμένη, τον έχουν τα ονοματεπώνυμα των υποψηφίων και τα πεδία των τιμών αντιπροσωπεύουν τις ψήφους που έχει συγκεντρώσει ο κάθε υποψήφιος. Επομένως, καταχωρούμε στη δομή $\mathtt{D}$ κάθε υποψήφιο του πίνακα υποψηφίων $\mathtt{C}$ ως κλειδί και αρχικοποιούμε την τιμή που του αντιστοιχεί σε μηδέν $(0)$. Έπειτα, δημιουργούμε έναν κενό πίνακα $\mathtt{POP\_CAND}$ τον οποίο θα επιστρέψουμε στο τέλος του αλγορίθμου.\par%
	Επόμενο βήμα είναι η σειριακή προσπέλαση του πίνακα των αποτελεσμάτων της δημοσκόπησης, $\mathtt{P}$. Κάθε ονοματεπώνυμο που είναι αποθηκευμένο στον πίνακα $\mathtt{P}$, το αναζητούμε ως κλειδί στο dictionary $\mathtt{D}$ και προσαυξάνουμε το πεδίο της τιμής \textsl{(value)} του κατά ένα. Με το πέρας της διαδικασίας αυτής, σε κάθε κλειδί--υποψήφιο αντιστοιχεί μία μη αρνητική τιμή--πλήθος ψήφων.\par
	Εν συνεχεία, προσπελάζουμε το dictionary $\mathtt{D}$ μέσω των κλειδιών του. Για κάθε κλειδί ελέγχουμε εάν η τιμή που του αντιστοιχεί είναι μεγαλύτερη του $\left\lceil\sfrac{N}{2}\right\rceil$. Εάν ναι, το όνομα του υποψηφίου--κλειδί προστίθεται στον πίνακα $\mathtt{POP\_CAND}$ ο οποίος επιστρέφεται και τερματίζεται ο αλγόριθμος. Εάν όχι, προχωράμε στο επόμενο κλειδί. Τέλος, εάν δεν βρεθεί κάποιος υποψήφιος ο οποίος να έχει συγκεντρώσει περισσότερες από τις μισές ψήφους, δηλαδή εάν η τιμή που του αντιστοιχεί στο $\mathtt{D}$ δεν είναι μεγαλύτερη του $\left\lceil\sfrac{N}{2}\right\rceil$, τότε επιστρέφεται ο κενός πίνακας $\mathtt{POP\_CAND}$ και τερματίζεται η διαδικασία. Ο αλγόριθμος δίνεται σε μορφή ψευδογλώσσας στο \textbf{Algorithm \ref{alg:1_3}}.\par
	Επόμενο βήμα είναι να αναλύσουμε την χρονική πολυπλοκότητα του \textbf{Algorithm \ref{alg:1_3}} και να αποδείξουμε πως είναι όντως $\bigO(n)$.\par%
	Η γραμμή $2$ τρέχει μία φορά και σε σταθερό χρόνο $\bigO(1)$ καθότι δημιουργείται κενό dictionary. Το σώμα της $\mathtt{\mathbf{for}}$ της γραμμής $3$ θα εκτελεστεί ακριβώς $M$ φορές, κάθε φορά σε σταθερό χρόνο $\bigO(1)$ \cit{knuthArt3}. Συνεπώς, η πολυπλοκότητά του είναι $\bigO(M)$. Η γραμμή $6$ εκτελείται μία φορά και σε σταθερό χρόνο $\bigO(1)$. Το σώμα της $\mathtt{\mathbf{for}}$ της γραμμής $7$ θα εκτελεστεί ακριβώς $M$ φορές, κάθε φορά σε σταθερό χρόνο $\bigO(1)$. Επομένως, ο συνολικός χρόνος εκτέλεσής του θα είναι $\bigO(M)$. Η γραμμή $10$ εκτελείται μία φορά και σε σταθερό χρόνο $\bigO(1)$. Η γραμμή $12$ εκτελείται $M$, το πολύ, φορές και κάθε φορά σε σταθερό χρόνο $\bigO(1)$. Σε σταθερό χρόνο τρέχουν και οι γραμμές $13$ και $14$ οι οποίες δύναται να εκτελεστούν μία, το πολύ, φορά. Τέλος, η γραμμή $17$ θα εκτελεστεί μία, το πολύ, φορά και σε σταθερό χρόνο $\bigO(1)$. Βάσει των παραπάνω, ο συνολικός χρόνος εκτέλεσης του \textbf{Algorithm \ref{alg:1_3}} θα είναι
	\begin{align*}
		T_3(N,M)&=\bigO(1)+M\cdot\bigO(1)+\bigO(1)+N\cdot\bigO(1)+\bigO(1)+M\cdot\left[\bigO(1)+\bigO(1)+\bigO(1)\right]+\bigO(1)\\
		&=\bigO(M)+\bigO(N).
	\end{align*}

	Χωρίς βλάβη της γενικότητας θέτουμε $n=\displaystyle{\max\left\{M,N\right\}}$. Τότε, ο συνολικός χρόνος εκτέλεσης του \textbf{Algorithm \ref{alg:1_3}} είναι γραμμικός και γράφεται

	\begin{equation}
		T_3(n)=\bigO\(n\)
	\end{equation}

	Σε ό,τι αφορά την διατήρηση της γραμμικότητας, απαραίτητη προϋπόθεση είναι να μην ισχύει καμία από τις ακόλουθες σχέσεις
	\begin{align}
		N&\to M^2\\
		M&\to N^2.
	\end{align}
	Διότι τότε, η χρονική πολυπλοκότητα θα ήταν $\bigO(n^2)$.
	\qed
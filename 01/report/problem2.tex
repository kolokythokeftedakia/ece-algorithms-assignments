\begin{problem}
	\label{problem2}
	Έστω πίνακας $T$ με στοιχεία $n$ θετικούς ακεραίους με εύρος $[0,\ldots,k]$ ($k$ ακέραιος). Δίνεται ο αλγόριθμος
	\begin{flushleft}
		\begin{algorithm}[H]
			\caption{}\label{alg:2_counting_sort}
			\texttt{\begin{algorithmic}[1]
				\For{$i=0,\ldots,k$}
					\State{$H[i]=0$}
				\EndFor
				\For{$j=1,\ldots,n$}
					\State{$H[T[j]]=H[T[j]]+1$}
				\EndFor
				\For{$i=1,\ldots,k$}
					\State{$H[i]=H[i]+H[i-1]$}
				\EndFor
				\For{$j=n,\ldots,1$}
					\State{$S[H[T[j]]]=T[j]$}
					\State{$H[T[j]]=H[T[j]]-1$}
				\EndFor
			\end{algorithmic}}
		\end{algorithm}
	\end{flushleft}
\end{problem}


Ο αλγόριθμος του \textbf{Προβλήματος \ref{problem2}} είναι ο αλγόριθμος ταξινόμησης \textsl{counting sort} (όπως συναντάται στην αγγλική βιβλιογραφία). \cit{knuthArt3}\cit{handbook}

\section{Περιγραφή πίνακα $S$}

	Αρχικά, στο \textbf{Πρόβλημα \ref{problem2}} δίνεται ένας πίνακας $n$ στοιχείων, $T$, με εύρος από $0$ έως $k$, όπου $k$ θετικός ακέραιος, τον οποίο θέλουμε να ταξινομήσουμε. Χρησιμοποιώντας έναν βοηθητικό πίνακα $H$, ο οποίος είναι zero-indexed, μεγέθους $k+1$ και έχοντας αρχικοποιήσει όλα του τα στοιχεία σε μηδέν (γραμμές $1$ έως και $3$), με την \texttt{\textbf{for}} των γραμμών $4$ έως και $6$ σαρώνουμε τον πίνακα $T$ και σε κάθε επανάληψη του βρόχου χρησιμοποιούμε την τιμή $T[j]$ ως δείκτη για τον πίνακα $H$ και πάμε στην θέση $H[T[j]]$, όπου αυξάνουμε το περιεχόμενό της κατά ένα, έτσι ώστε με το πέρας της \texttt{\textbf{for}} των γραμμών $4$ έως και $6$, ο $H$ να είναι πίνακας συχνοτήτων εμφάνισης του κάθε ακέραιου (index του $H$) στον $T$.\par
	Έπειτα, έχοντας συμπληρώσει τον πίνακα $H$ για κάθε ακέραιο (index του) με το πλήθος εμφανίσεων αυτού στον $T$, περνάμε στο \texttt{\textbf{for}} των γραμμών $7$ έως και $9$, όπου ενημερώνουμε τον $H$ με τον ακόλουθο τρόπο. Αρχικά, αφήνουμε το περιεχόμενο στην θέση $H[0]$ αναλλοίωτο και για το $H[1]$ μέχρι και το $H[k]$ ενημερώνουμε το $H[i]$ με την τιμή $H[i] + H[i-1]$, δηλαδή την τιμή του αθροίσματος του περιεχομένου της θέσης του $H$ που υποδεικνύεται από τον μετρητή του βρόχου επανάληψης συν το περιεχόμενο της προηγούμενης θέσης του $H$. Οπότε, τελικά θα έχουμε έναν πίνακα $H$ ο οποίος σε κάθε θέση του, $x$,  θα περιέχει την θέση--index του ακεραίου $x$ στον ταξινομημένο πίνακα.\par
	Τώρα, έχοντας την νέα μορφή του πίνακα $H$ στα χέρια μας θα χρησιμοποιήσουμε έναν ακόμη βοηθητικό πίνακα $S$ μεγέθους $n$ (και zero-indexed) στον οποίο \textbf{θα αποθηκευτεί το ταξινομημένο αποτέλεσμα}. Ξεκινάμε τον μετρητή του \texttt{\textbf{for}}, των γραμμών $10$ έως και $13$, από το τέλος του πίνακα $Τ$, δηλαδή από το $n$ και τον μειώνουμε μέχρι να φτάσει και στην θέση $1$. Καθώς σαρώνουμε τον $T$ με τον μετρητή $j$, χρησιμοποιούμε ως δείκτη το περιεχόμενο του $T[j]$ για να προσπελάσουμε το αντίστοιχο στοιχείο στον $H$, δηλαδή $H[T[j]]$, και αφού πλέον ο $H$ περιέχει τις θέσεις τον ακεραίων στον πίνακα $S$, θέτουμε $S[H[T[j]]] = T[j]$, καταχωρώντας έτσι στον πίνακα $S$, τα στοιχεία του πίνακα $T$, στις σωστές--ταξινομημένες θέσεις τους. Έπειτα της τοποθέτησης του στοιχείου $T[j]$ στην σωστή του θέση στον ταξινομημένο πίνακα $S$, μειώνουμε το περιεχόμενο του πίνακα $H$ στην θέση $T[j]$ κατά ένα. Αυτή η κίνηση είναι ιδιαίτερα χρήσιμη στην περίπτωση ύπαρξης διπλοτύπων στον πίνακα $T$ διότι μόλις συναντήσουμε έναν ακέραιο για δεύτερη (ή οποιαδήποτε) φορά, θα τον τοποθετήσουμε στην αμέσως προηγούμενη θέση από το στοιχείο με την ίδια τιμή. \par
	Παρακάτω, παραθέτουμε ένα \textbf{παράδειγμα εκτέλεσης} του αλγορίθμου με $T=[1,0,3,1,3,1]$. Είναι, δηλαδή, $n=6$ και $k=3$.

	\begin{center}
		\input{counting_sort_example.tex}
	\end{center}

	Μέσω του παραπάνω παραδείγματος επαληθεύεται ο ισχυρισμός πως \textbf{ο πίνακας $S$ είναι η ταξινομημένη μορφή του πίνακα $T$} και επιπλέον αναδεικνύεται μία σημαντική ιδιότητα του αλγορίθμου \textsl{counting sort}. Στοιχεία του πίνακα $T$ τα οποία έχουν την ίδια τιμή, εμφανίζονται στον πίνακα $S$ με την ίδια σειρά που εμφανίζονται και στον $T$ \cit{handbook}. Αλγόριθμοι ταξινόμησης με αυτήν την ιδιότητα αποκαλούνται \textsl{stable} \cit{knuthArt3}. Αυτο επιτυγχάνεται ξεκινώντας τον μετρητή της \texttt{\textbf{for}} των γραμμών $10$-$13$, από την τιμή $n$.

\section{Ανάλυση χρόνου εκτέλεσης}

	Στην παρούσα ενότητα θα αναλύσουμε τον χρόνο εκτέλεσης του \textbf{Algorithm \ref{alg:2_counting_sort}} (counting sort). Ωστόσο, πριν αυτού, αξίζει να γίνουν κάποιες παρατηρήσεις σχετικά με την φύση του αλγορίθμου. Ο \textbf{Algorithm \ref{alg:2_counting_sort}} ανήκει σε μία οικογένεια αλγορίθμων ταξινόμησης οι οποίοι δεν χρησιμοποιούν συγκρίσεις μεταξύ των στοιχείων όπως παραδείγματος χάριν ο quick-sort ή ο bubble-sort. Για τους αλγόριθμους ταξινόμησης των οποίων η αρχή λειτουργίας στηρίζεται σε συγκρίσεις μεταξύ των στοιχείων αποδεικνύεται πως η χρονική τους πολυπλοκότητα έχει κάτω φράγμα και συγκεκριμένα είναι $\Omega(n\lg{n})$ \cit{handbook}. Ωστόσο, εγκαταλείποντας το μοντέλο των συγκρίσεων, παύει να ισχύει και το κάτω φράγμα $\Omega(n\lg{n})$ \cit{handbook}.\par
	Αρχικά, ο πίνακας με τα δεδομένα προς ταξινόμηση, $T$, έχει $n$ στοιχεία. Κάθε μία από τις γραμμές $2$, $5$, $8$, $11$ και $12$ του \textbf{Algorithm \ref{alg:2_counting_sort}} απαιτεί σταθερό χρόνο εκτέλεσης $\bigO(1)$. Επομένως, έχουμε
	\begin{enumerate}[label=\roman*.]
		\item Το σώμα του \texttt{\textbf{for}} των γραμμών $1-3$ τρέχει $k+1$ φορές. Επομένως, ο χρόνος εκτέλεσής του είναι $(k+1)\cdot\bigO(1)=\bigO(k+1)=\bigO(k)$.
		\item Το σώμα του \texttt{\textbf{for}} των γραμμών $4-5$ εκτελείται $n$ φορές. Επομένως, ο χρόνος εκτέλεσής του είναι $n\cdot\bigO(1)=\bigO(n)$.
		\item Το σώμα του \texttt{\textbf{for}} των γραμμών $7-9$ εκτελείται $k$ φορές. Επομένως, ο χρόνος εκτέλεσής του είναι $k\cdot\bigO(1)=\bigO(k)$.
		\item Το σώμα του \texttt{\textbf{for}} των γραμμών $10-13$ εκτελείται $n$ φορές. Επομένως, ο χρόνος εκτέλεσής του είναι $n\cdot(\bigO(1)+\bigO(1))=\bigO(n)$.
	\end{enumerate}
 Προσθέτοντας τους παραπάνω χρόνους προκύπτει πως τελικά ο χρόνος εκτέλεσης του \textbf{Algorithm \ref{alg:2_counting_sort}} είναι
\begin{equation*}
	T(n,k)=\bigO(k)+\bigO(n)+\bigO(k)+\bigO(n)
\end{equation*}

\begin{center}
	ή
	\vspace*{-14pt}
\end{center}

\begin{equation}
	\label{eq:counting_sort_O(n+k)}
	T(n,k)=\bigO(n+k).
\end{equation}

Δηλαδή, ο αλγόριθμος είναι γραμμικής χρονικής πολυπλοκότητας. Προκειμένου να επιτύχουμε την καλύτερη δυνατή λειτουργία του δεν θα πρέπει το εύρος τιμών, $k$, να είναι πολύ μεγαλύτερο από το $n$ αλλά, να έχει ως άνω όριο το $\bigO(n)$, δηλαδή $k = \bigO(n)$. Αυτή είναι κιόλας η συνήθης περίπτωση εφαρμογής του αλγορίθμου, διότι τότε ο χρόνος εκτέλεσής του γίνεται $T(n)=\bigO(2\cdot n)=\bigO(n)$ \cit{handbook}. Επιπλέον προϋπόθεση για την διατήρηση της γραμμικότητας του χρόνου εκτέλεσης του \textbf{Algorithm \ref{alg:2_counting_sort}} είναι το $k$ να μην προσεγγίζει το $n^{2}$, διότι τότε, ο χρόνος εκτέλεσης τους αλγορίθμου θα είναι $\bigO(n+n^2)$, δηλαδή $\bigO(n^2)$ καθιστώντας τον μη αποδοτικό.